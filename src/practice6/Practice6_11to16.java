package practice6;

/*
 * 6-11 다음 중 아래의 add메서드를 올바르게 오버로딩 한 것은? (모두 고르시오)
 *     long add(int a, int b) { return a + b; }
 *
 *     1 long add(int x, int y)   { return x+y; }  // 변수명은 오버로딩의 조건이 아니다.
 *     2 long add(long a, long b) { return a+b; }  // ok. 오버로딩의 조건 2 매개변수의 타입 또는 갯수가 달라야 한다.
 *     3 int add(byte a, byte b)  { return a+b; }  // ok. 오버로딩의 조건 2 매개변수의 타입 또는 갯수가 달라야 한다.
 *     4 int add(long a, int b)   { return (int)(a+b); }  // ok. 오버로딩의 조건 2 매개변수의 타입 또는 갯수가 달라야 한다.
 * */

/*
 * 6-12. 다음 중 초기화에 대한 설명으로 옳지 않은 것은? (모두 고르시오)
 *      1 멤버변수는 자동 초기화되므로 초기화하지 않고도 값을 참고할 수 있다.  // ok.
 *      2 지역변수는 사용하기 전에 반드시 초기화해야 한다.  // ok.
 *      3 초기화 블럭보다 생성자가 먼저 수행된다.        // (x) 초기화블럭이 먼저 수행된다.
 *      4 명시적 초기화를 제일 우선적으로 고려해야 한다.   // ok.
 *      5 클래스 변수보다 인스턴스 변수가 먼저 초기화 된다  // (x) cv -> iv : 멤버변수 초기화 순서
 */

/*
 * 6-13. 다음 중 인스턴스 변수의 초기화 순서가 올바른 것은?
 *       1 기본값 - 명시적 초기화 - 초기화 블럭 - 생성자
 */

/*
 * 6-14. 다음 중 지역변수에 대한 설명으로 옳지 않은 것은? (모두 고르시오)
 *      1 자동 초기화되므로 별도의 쵝화가 필요 없다.  // 지역변수는 사용 전에 반드시 '수동 초기화'해야 한다.
 *      2 지역변수가 선언된 메서드가 종료되면 지역변수도 함께 소멸한다  // ok.
 *      3 메서드의 매개변수로 선언된 변수도 지역변수이다.  // ok.
 *      4 클래스 변수나 인스턴스 변수보다 메모리 부담이 적다.  // ok.
 *      5 힙(heap)영역에 생성되며 가비지 컬렉터에 의해 소멸된다.  // 인스턴스 변수에 대한 설명이다.
 */

/*
 *      ----------
 *      println
 *      ----------
 *      method1
 *      ----------
 *      method2
 *      ----------
 *      main
 *      ----------
 * 6-15. 호출스택이 다음과 같은 상황일 때 옳지 않은 설명은? (모두 고르시오)
 *      1 제일 먼저 호출스택에 저장된 것은 main메서드이다.  // ok.
 *      2 println메서드를 제외한 나머지 메서드들은 모두 종료된 상태이다. // (X) 대기 중 상태이다.
 *      3 method2메서드를 호출한 것은 main메서드이다.    // ok.
 *      4 println메서드가 종료되면 method1메서드가 수행을 재개한다.  // ok.
 *      5 main-method2-method1-println의 순서로 호출되었다.    // ok.
 *      6 현재 실행중인 메서드는 println 뿐이다.        // ok.
 */

/*
 * 6-16. 다음 코드의 실행 결과를 예측하여 적으시오.
 */

class Practice6_11to16 {
    public static void change(String str) {
        str += "456";
    }

    public static void main(String[] args) {
        String str = "ABC123";
        System.out.println(str);
        change(str);
        System.out.println("After change:" + str);
    }

}

/*
 * 정답
 * ABC123
 * After change:ABC123
 * 문자열의 내용을 변경할 수 없기 때문에 덧셈연산을 하면 새로운 문자열이 생성되고 새로운 문자열의 주소가 변수 str에 저장된다.
 * 참고 : CHAPTER9-7 String클래스(330P)
 */
